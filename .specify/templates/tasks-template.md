---
description: '기능 구현을 위한 태스크 목록 템플릿'
---

# 태스크: [FEATURE NAME]

**입력**: `/specs/[###-feature-name]/`의 설계 문서
**선행조건**: plan.md (필수), spec.md (사용자 스토리에 필수), research.md, data-model.md, contracts/

**테스트**: 아래 예시에는 테스트 태스크가 포함됩니다. 테스트는 선택사항 - 기능 명세서에 명시적으로 요청된 경우에만 포함하세요.

**구성**: 태스크는 각 스토리의 독립적인 구현 및 테스트를 가능하게 하기 위해 사용자 스토리별로 그룹화됩니다.

## 형식: `[ID] [P?] [Story] 설명`

- **[P]**: 병렬 실행 가능 (다른 파일, 의존성 없음)
- **[Story]**: 이 태스크가 속한 사용자 스토리 (예: US1, US2, US3)
- 설명에 정확한 파일 경로 포함

## 경로 규칙

- **Next.js + FSD**: 라우트는 `app/`, `src/features/`, `src/entities/`, `src/shared/` 등
- **대안**: 루트에 `features/`, `entities/`, `shared/`가 있는 플랫 구조
- **테스트**: 구현과 함께 위치 (예: `features/auth/ui/__tests__/`)
- 아래 표시된 경로는 FSD 구조를 가정 - plan.md에 따라 조정

<!--
  ============================================================================
  중요: 아래 태스크는 예시 목적의 샘플 태스크입니다.

  /speckit.tasks 명령은 다음을 기반으로 실제 태스크로 교체해야 합니다:
  - spec.md의 사용자 스토리 (우선순위 P1, P2, P3...)
  - plan.md의 기능 요구사항
  - data-model.md의 엔티티
  - contracts/의 엔드포인트

  태스크는 각 스토리가 다음을 수행할 수 있도록 사용자 스토리별로 구성되어야 합니다:
  - 독립적으로 구현
  - 독립적으로 테스트
  - MVP 증분으로 전달

  생성된 tasks.md 파일에 이러한 샘플 태스크를 유지하지 마세요.
  ============================================================================
-->

## Phase 1: 설정 (공유 인프라)

**목적**: 프로젝트 초기화 및 FSD 구조

- [ ] T001 구현 계획에 따른 FSD 디렉토리 구조 생성 (features/, entities/, shared/)
- [ ] T002 필요한 라우트로 Next.js App Router 구조 초기화
- [ ] T003 [P] FSD를 위한 TypeScript strict 모드 및 경로 별칭 설정
- [ ] T004 [P] Next.js 및 FSD import 규칙과 함께 ESLint 설정

---

## Phase 2: 기반 (차단 선행조건)

**목적**: 모든 사용자 스토리 구현 전에 완료되어야 하는 핵심 인프라

**⚠️ 중요**: 이 단계가 완료될 때까지 사용자 스토리 작업을 시작할 수 없습니다

기반 태스크 예시 (프로젝트에 따라 조정):

- [ ] T005 `shared/ui/`에 공유 UI 컴포넌트 설정 (Button, Input 등)
- [ ] T006 [P] `entities/[entity]/model/types.ts`에 기본 엔티티 타입 생성
- [ ] T007 [P] `shared/api/client.ts`에 API 클라이언트 설정
- [ ] T008 `shared/config/`에 환경 변수 및 공유 설정 구성
- [ ] T009 `shared/lib/errors/`에 에러 처리 유틸리티 설정
- [ ] T010 `app/providers/`에 앱 프로바이더 생성 (Theme, Auth 등)
- [ ] T011 [P] `shared/types/`에 전역 타입 설정

**체크포인트**: 기반 준비 완료 - 이제 기능 구현을 병렬로 시작할 수 있음

---

## Phase 3: 사용자 스토리 1 - [제목] (우선순위: P1) 🎯 MVP

**목표**: [이 스토리가 제공하는 것에 대한 간단한 설명]

**독립 테스트**: [이 스토리가 독립적으로 작동하는지 검증하는 방법]

### 사용자 스토리 1 테스트 (선택사항 - 테스트가 요청된 경우에만) ⚠️

> **참고: 이 테스트를 먼저 작성하고, 구현 전에 실패하는지 확인하세요**

- [ ] T012 [P] [US1] `features/[feature]/ui/__tests__/`에 [Feature UI]의 컴포넌트 테스트
- [ ] T013 [P] [US1] `app/api/[route]/__tests__/`에 API 라우트 테스트
- [ ] T014 [P] [US1] `__tests__/integration/`에 [user journey]의 통합 테스트

### 사용자 스토리 1 구현

**엔티티 (비즈니스 객체)**:

- [ ] T015 [P] [US1] `entities/[entity]/model/types.ts`에 [Entity] 타입 생성
- [ ] T016 [P] [US1] `entities/[entity]/api/`에 [Entity] API 생성
- [ ] T017 [P] [US1] `entities/[entity]/ui/`에 [Entity] UI 컴포넌트 생성
- [ ] T018 [US1] `entities/[entity]/index.ts`를 통해 엔티티 public API export

**기능 (사용자 기능)**:

- [ ] T019 [US1] `features/[feature]/model/`에 기능 모델 생성 (hooks, state, types)
- [ ] T020 [US1] `features/[feature]/ui/[Component].tsx`에 기능 UI 구현
- [ ] T021 [US1] `features/[feature]/api/`에 기능 API 통합 추가
- [ ] T022 [US1] `features/[feature]/lib/`에 기능 유틸리티 생성
- [ ] T023 [US1] `features/[feature]/index.ts`를 통해 기능 public API export

**페이지/라우트**:

- [ ] T024 [US1] `app/[route]/page.tsx`에 Next.js 라우트 생성
- [ ] T025 [US1] 필요시 `app/[route]/layout.tsx`에 라우트 레이아웃 생성
- [ ] T026 [US1] widgets/features에서 페이지 구성

**검증**:

- [ ] T027 [US1] 하위→상위 import 없는지 검증 (상위가 하위 import: pages→widgets→features→entities→shared)
- [ ] T028 [US1] TypeScript strict 모드 준수 검증
- [ ] T029 [US1] ESLint 실행 및 위반사항 수정

**체크포인트**: 이 시점에서 사용자 스토리 1은 완전히 작동하고 독립적으로 테스트 가능해야 함

---

## Phase 4: 사용자 스토리 2 - [제목] (우선순위: P2)

**목표**: [이 스토리가 제공하는 것에 대한 간단한 설명]

**독립 테스트**: [이 스토리가 독립적으로 작동하는지 검증하는 방법]

### 사용자 스토리 2 테스트 (선택사항 - 테스트가 요청된 경우에만) ⚠️

- [ ] T030 [P] [US2] `features/[feature]/ui/__tests__/`에 [Feature UI]의 컴포넌트 테스트
- [ ] T031 [P] [US2] `app/api/[route]/__tests__/`에 API 라우트 테스트

### 사용자 스토리 2 구현

**엔티티**: [새로운 엔티티가 필요한 경우]

- [ ] T032 [P] [US2] FSD 구조를 따라 `entities/[entity]/`에 [Entity] 생성

**기능**:

- [ ] T033 [US2] `features/[feature]/model/`에 기능 모델 생성
- [ ] T034 [US2] `features/[feature]/ui/`에 기능 UI 구현
- [ ] T035 [US2] `features/[feature]/index.ts`를 통해 기능 public API export

**페이지/라우트**:

- [ ] T036 [US2] `app/[route]/page.tsx`에 라우트 생성/업데이트
- [ ] T037 [US2] 필요시 사용자 스토리 1과 통합 (public API를 통해서만)

**검증**:

- [ ] T038 [US2] FSD 준수 및 TypeScript strict 모드 검증

**체크포인트**: 이 시점에서 사용자 스토리 1과 2가 모두 독립적으로 작동해야 함

---

## Phase 5: 사용자 스토리 3 - [제목] (우선순위: P3)

**목표**: [이 스토리가 제공하는 것에 대한 간단한 설명]

**독립 테스트**: [이 스토리가 독립적으로 작동하는지 검증하는 방법]

### 사용자 스토리 3 테스트 (선택사항 - 테스트가 요청된 경우에만) ⚠️

- [ ] T039 [P] [US3] `features/[feature]/ui/__tests__/`에 컴포넌트 테스트
- [ ] T040 [P] [US3] [user journey]의 통합 테스트

### 사용자 스토리 3 구현

- [ ] T041 [P] [US3] FSD 구조를 따라 entities/features 생성
- [ ] T042 [US3] 기능 로직 및 UI 구현
- [ ] T043 [US3] `app/`에 라우트 생성/업데이트
- [ ] T044 [US3] FSD 준수 검증

**체크포인트**: 모든 사용자 스토리가 이제 독립적으로 작동해야 함

---

[필요에 따라 동일한 패턴으로 더 많은 사용자 스토리 단계 추가]

---

## Phase N: 마무리 및 횡단 관심사

**목적**: 여러 사용자 스토리에 영향을 미치는 개선사항

- [ ] TXXX [P] `docs/`에 문서 업데이트
- [ ] TXXX 코드 정리 및 리팩토링
- [ ] TXXX 모든 스토리에 걸친 성능 최적화
- [ ] TXXX [P] (요청된 경우) `tests/unit/`에 추가 단위 테스트
- [ ] TXXX 보안 강화
- [ ] TXXX quickstart.md 검증 실행

---

## 의존성 및 실행 순서

### Phase 의존성

- **설정 (Phase 1)**: 의존성 없음 - 즉시 시작 가능
- **기반 (Phase 2)**: 설정 완료에 의존 - 모든 사용자 스토리를 차단
- **사용자 스토리 (Phase 3+)**: 모두 기반 단계 완료에 의존
  - 이후 사용자 스토리는 병렬로 진행 가능 (인력이 있는 경우)
  - 또는 우선순위 순서로 순차적으로 (P1 → P2 → P3)
- **마무리 (최종 Phase)**: 원하는 모든 사용자 스토리가 완료되는 것에 의존

### 사용자 스토리 의존성

- **사용자 스토리 1 (P1)**: 기반 (Phase 2) 이후 시작 가능 - 다른 스토리에 대한 의존성 없음
- **사용자 스토리 2 (P2)**: 기반 (Phase 2) 이후 시작 가능 - US1과 통합될 수 있지만 독립적으로 테스트 가능해야 함
- **사용자 스토리 3 (P3)**: 기반 (Phase 2) 이후 시작 가능 - US1/US2와 통합될 수 있지만 독립적으로 테스트 가능해야 함

### 각 사용자 스토리 내에서

- 테스트(포함된 경우)는 반드시 작성되고 구현 전에 실패해야 함
- 서비스 전에 모델
- 엔드포인트 전에 서비스
- 통합 전에 핵심 구현
- 다음 우선순위로 넘어가기 전에 스토리 완료

### 병렬 처리 기회

- [P]로 표시된 모든 설정 태스크는 병렬 실행 가능
- [P]로 표시된 모든 기반 태스크는 병렬 실행 가능 (Phase 2 내에서)
- 기반 단계가 완료되면, 모든 사용자 스토리를 병렬로 시작 가능 (팀 역량이 허용하는 경우)
- [P]로 표시된 사용자 스토리의 모든 테스트는 병렬 실행 가능
- [P]로 표시된 스토리 내의 모델은 병렬 실행 가능
- 다른 사용자 스토리를 다른 팀원이 병렬로 작업 가능

---

## 병렬 처리 예시: 사용자 스토리 1

```bash
# 사용자 스토리 1의 모든 테스트를 함께 시작 (테스트가 요청된 경우):
태스크: "`features/[feature]/ui/__tests__/`에 [Feature UI]의 컴포넌트 테스트"
태스크: "`app/api/[route]/__tests__/`에 API 라우트 테스트"

# 사용자 스토리 1의 모든 모델을 함께 시작:
태스크: "`entities/[entity]/model/types.ts`에 [Entity1] 타입 생성"
태스크: "`entities/[entity]/model/types.ts`에 [Entity2] 타입 생성"
```

---

## 구현 전략

### MVP 우선 (사용자 스토리 1만)

1. Phase 1 완료: 설정
2. Phase 2 완료: 기반 (중요 - 모든 스토리 차단)
3. Phase 3 완료: 사용자 스토리 1
4. **중지 및 검증**: 사용자 스토리 1을 독립적으로 테스트
5. 준비되면 배포/데모

### 점진적 전달

1. 설정 + 기반 완료 → 기반 준비됨
2. 사용자 스토리 1 추가 → 독립적으로 테스트 → 배포/데모 (MVP!)
3. 사용자 스토리 2 추가 → 독립적으로 테스트 → 배포/데모
4. 사용자 스토리 3 추가 → 독립적으로 테스트 → 배포/데모
5. 각 스토리는 이전 스토리를 깨뜨리지 않고 가치를 추가

### 병렬 팀 전략

여러 개발자가 있는 경우:

1. 팀이 함께 설정 + 기반 완료
2. 기반이 완료되면:
   - 개발자 A: 사용자 스토리 1
   - 개발자 B: 사용자 스토리 2
   - 개발자 C: 사용자 스토리 3
3. 스토리가 독립적으로 완료되고 통합됨

---

## 참고사항

- [P] 태스크 = 다른 파일/레이어, 의존성 없음
- [Story] 라벨은 추적을 위해 태스크를 특정 사용자 스토리에 매핑
- 각 사용자 스토리는 독립적으로 완료 및 테스트 가능해야 함
- FSD 레이어 순서: shared ← entities ← features ← widgets ← pages ← app (화살표 방향으로 import 가능, 역방향 금지)
- 모든 코드는 TypeScript strict 모드 사용
- index 파일을 통해 public API export
- 구현 전에 테스트가 실패하는지 검증
- 각 태스크 또는 논리적 그룹 후에 커밋
- 체크포인트에서 중지하여 스토리를 독립적으로 검증
- 피해야 할 것: 모호한 태스크, 하위→상위 레이어 import, 순환 의존성, 정당화되지 않은 `any` 타입
